# 회귀테스트 논의 정리

## 논의 배경

- 기능 추가 후 회귀테스트 수행에 대한 의문점 제기
- 기존 테스트 코드와 회귀테스트의 차이점에 대한 혼란

## 주요 의문점

### 여진석님의 의문

1. **기존 테스트와의 중복성**

   - 이미 작성된 테스트 코드와 동일한 내용을 회귀테스트로 또 작성해야 하는지?
   - 예: "단일 일정 생성 기능 검증 / 반복 설정이 비활성화된 상태에서 기본 동작"이 이미 테스트에 있음

2. **회귀테스트의 의미**

   - 기능 A, B를 만들었다고 해서 기능 A, B가 삭제된 상태를 회귀했다고 봐야 하는지?
   - 단순히 기존 기능을 한번 더 테스트하는 것이 회귀테스트인지?

3. **회귀테스트의 목적**
   - 새로운 기능이 추가되었을 때, 에러가 나는 상황들에 대한 검증이 회귀테스트인지?

## 박준형님의 해석

### 회귀테스트의 정의

- **스키마 변경과 필드 추가에 대한 대응**
  - 새로운 필드가 추가되었을 때에도 기존의 기능이 유지되도록 만드는 것
  - 이것이 회귀테스트의 일부분

### 실제 적용 예시

```javascript
describe('기존 반복 계산 로직이 excludeDates 추가 후에도 동일하게 동작한다');
describe('weekday 기능 추가 이후에도 기본 주간/월간/연간 로직은 동일하게 동작한다');
```

## 결론

### 회귀테스트의 핵심

- **기존 기능의 유지 보장**: 새로운 기능 추가 시 기존 기능이 정상 동작하는지 확인
- **연관 기능 검증**: 다섯 가지 기능이 동작했을 때 기존 동작 중 연관된 기능들이 제대로 동작하는가에 대한 테스트

### 회귀테스트 작성 방향

- 단순한 기능 재테스트가 아닌 **기능 간 상호작용 검증**
- 새로운 필드나 로직 추가 시 **기존 로직의 안정성 보장**
- **통합적인 관점**에서의 기능 검증

## 참고 예시

김효진님이 제공한 예시:

```javascript
it('반복일정 중 일부가 기존 일정과 충돌하는 경우를 감지한다', () => {
  const repeatEvent: Event = {
    // ... 반복 일정 설정
  };

  const generatedEvents = generateRepeatEvents(repeatEvent, new Date('2025-01-16'));
  const conflictingEvents = findOverlappingEvents(generatedEvents[1], [existingEvent]);

  expect(conflictingEvents).toHaveLength(1);
  expect(conflictingEvents[0].id).toBe('1');
});
```

이 예시는 새로운 반복 기능이 추가되었을 때 기존의 충돌 감지 로직이 정상적으로 작동하는지를 검증하는 회귀테스트의 좋은 예시입니다.

[ ] 반복일정 생성 시 기존 단일 일정들과 충돌 검사가 정상 동작하는지
[ ] 반복일정이 검색 기능에 정상적으로 포함되는지
[ ] 반복일정에 대한 알림이 각 일정마다 정상 동작하는지
